# 18_dt_probe

## 관련개념
**Device Tree**, **probe() 함수**, **platform_driver()**는 모두 **임베디드 시스템**이나 **리눅스 커널**에서 하드웨어 장치와 소프트웨어 간의 상호작용을 처리하는데 중요한 개념들입니다. 이들 개념의 도입 배경을 설명하면서, 각각이 어떻게 하드웨어 장치 관리 문제를 해결하는지 자세히 설명하겠습니다.

---

### 1. **Device Tree (디바이스 트리)**

#### **도입 배경**
기존의 **하드웨어 초기화 방식**은 커널 코드에 직접적으로 하드웨어 관련 정보를 포함하는 방식이었습니다. 이는 다음과 같은 문제들을 발생시켰습니다:
- **하드웨어 종속성**: 커널 코드에 특정 하드웨어 플랫폼에 대한 정보가 직접 하드코딩되었기 때문에, 하드웨어를 변경하거나 새로운 플랫폼을 지원하려면 커널 자체를 수정해야 했습니다.
- **유연성 부족**: 다양한 하드웨어 플랫폼에서 동일한 커널을 사용하는 것이 어려웠습니다. 커널이 하드웨어에 대해 알고 있어야 했고, 새로운 장치나 변경 사항을 지원하기 위해 커널을 자주 수정해야 했습니다.

이러한 문제를 해결하기 위해 **디바이스 트리(Device Tree)** 가 도입되었습니다. 디바이스 트리는 **하드웨어의 구성 정보를 외부 파일**로 분리하여, 커널이 특정 하드웨어에 대한 정보를 미리 알지 않아도 하드웨어를 초기화할 수 있도록 합니다.
디바이스 트리는 **하드웨어를 설명하는 데이터 구조**입니다. 이 데이터 구조는 텍스트 형식으로 작성된 **Device Tree Source 파일(.dts)** 과 컴파일된 **Device Tree Blob(.dtb)** 파일로 존재하며, 이 파일을 통해 커널은 하드웨어 장치의 특성을 알게 됩니다.

---

### 2. **probe() 함수**

임베디드 시스템에서는 장치들이 **플러그 앤 플레이(Plug and Play)** 방식으로 동적으로 감지되기 보다는, 시스템 부팅 시 이미 존재하는 장치들이 초기화됩니다. 이를 위해 커널은 특정 장치 드라이버가 해당 하드웨어 장치와 연결될 수 있도록 초기화하는 과정이 필요합니다. 이러한 과정에서 **probe() 함수**가 도입되었습니다.
`probe()` 함수는 **장치 드라이버가 특정 하드웨어 장치를 초기화**할 때 호출되는 함수입니다. 커널이 부팅되거나 장치가 등록될 때, 커널은 각 장치 드라이버의 `probe()` 함수를 호출하여 장치와 드라이버를 연결합니다.
- **하드웨어 장치의 존재 확인**: `probe()` 함수는 드라이버가 관리하는 장치가 실제로 존재하는지 확인합니다.
- **장치 초기화**: 하드웨어 장치의 자원(메모리, 인터럽트 등)을 할당하고, 드라이버와 장치를 연결합니다.
- **장치 등록**: 커널에 장치를 등록하여, 다른 커널 기능이나 사용자 공간 프로그램이 이 장치와 상호작용할 수 있도록 합니다.


---

### 3. **platform_driver()**

#### **도입 배경**
리눅스 커널에서는 하드웨어 장치에 따라 다양한 드라이버 인터페이스가 존재합니다. 그중에서도 **플랫폼 장치(platform device)** 는 주로 CPU나 SoC(System on Chip)와 관련된 장치들로, 이러한 장치를 처리하는 플랫폼 드라이버가 필요합니다. 플랫폼 장치는 일반적으로 **버스(bus)** 가 없기 때문에, 이를 관리하는 플랫폼 드라이버가 도입되었습니다.

#### **platform_driver()란?**
`platform_driver`는 **플랫폼 장치를 관리하는 드라이버 구조체**로, `probe()` 함수와 `remove()` 함수를 등록하여 특정 플랫폼 장치에 대해 드라이버가 동작하도록 합니다.

- **platform_device**: 플랫폼 장치는 별도의 버스 없이 직접적으로 메모리 매핑된 장치입니다. SoC에 내장된 장치들이 주로 플랫폼 장치로 처리됩니다.
- **platform_driver 구조체**: 해당 구조체는 플랫폼 장치와 연동되는 드라이버를 정의하며, **장치의 초기화**, **자원 할당**, **드라이버 제거** 등의 작업을 수행하는 콜백 함수들을 포함합니다.





## A. Demo
![dt_probe](https://github.com/user-attachments/assets/7c04872f-83d5-4622-845b-1bc227e85e29)
![dt_probe2](https://github.com/user-attachments/assets/846eaa94-59ef-464e-8041-9d8ea239f9ef)
![dt_probe3](https://github.com/user-attachments/assets/4c6de300-00e4-46a2-a61b-5082dd37db3f)



## B. 함수 호출 순서

이 코드는 플랫폼 드라이버가 로드될 때 장치 트리(Device Tree)에서 특정 장치 및 해당 속성을 파싱하여 처리하는 Linux 커널 모듈입니다. 함수 호출 순서는 다음과 같습니다.

### 1. 모듈 로드 시 (`my_init` 호출)
   - `module_init()` 매크로에 의해 **my_init** 함수가 커널 모듈이 로드될 때 호출됩니다.

#### 1-1. **platform_driver_register()** 호출
   - **플랫폼 드라이버 등록**: `platform_driver_register()` 함수로 `my_driver` 구조체에 정의된 플랫폼 드라이버를 커널에 등록합니다.
   - 드라이버가 등록되면 커널은 장치 트리에 정의된 장치와 해당 드라이버의 호환성을 확인하고, 호환되는 장치가 있는 경우 `dt_probe()` 함수를 호출하여 장치를 처리합니다.
   - 등록에 실패하면 에러 메시지를 출력하고 함수가 종료됩니다.

### 2. 드라이버가 등록된 장치 트리와 매칭될 때 (`dt_probe` 호출)
   - 플랫폼 장치가 드라이버와 매칭되면 **dt_probe** 함수가 호출됩니다.

#### 2-1. **device_property_present()** 호출 (속성 확인)
   - **속성 존재 여부 확인**: `device_property_present()` 함수를 사용해 장치 트리에서 `label`과 `my_value` 속성이 있는지 확인합니다.
   - 속성이 없으면 에러 메시지를 출력하고 `-1`을 반환하여 프로브 과정을 중지합니다.

#### 2-2. **device_property_read_string()** 및 **device_property_read_u32()** 호출 (속성 읽기)
   - **속성 읽기**: `device_property_read_string()`으로 `label` 속성을 읽고, `device_property_read_u32()`로 `my_value` 속성을 읽습니다.
   - 읽기에 실패하면 에러 메시지를 출력하고 함수가 종료됩니다.
   - 성공적으로 속성을 읽으면 해당 값을 출력합니다.

### 3. 모듈 언로드 시 (`my_exit` 호출)
   - `module_exit()` 매크로에 의해 **my_exit** 함수가 모듈이 언로드될 때 호출됩니다.

#### 3-1. **platform_driver_unregister()** 호출
   - **플랫폼 드라이버 등록 해제**: `platform_driver_unregister()` 함수로 등록된 플랫폼 드라이버를 시스템에서 해제합니다.
   - 이로 인해 더 이상 해당 장치에 대한 처리를 수행하지 않게 됩니다.

### 함수 호출 순서 요약

1. **my_init()** → 모듈 로드, 플랫폼 드라이버 등록
   - `platform_driver_register()`로 플랫폼 드라이버 등록

2. **dt_probe()** → 장치가 드라이버와 매칭될 때 호출
   - `device_property_present()`로 장치 트리 속성 확인
   - `device_property_read_string()` 및 `device_property_read_u32()`로 속성 읽기

3. **my_exit()** → 모듈 언로드, 플랫폼 드라이버 해제
   - `platform_driver_unregister()`로 플랫폼 드라이버 해제

이 순서는 플랫폼 드라이버가 장치 트리에서 정의된 특정 장치와 매칭될 때 해당 속성을 파싱하여 처리하는 과정을 설명합니다.
