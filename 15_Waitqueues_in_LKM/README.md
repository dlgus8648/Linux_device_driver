# 15_Waitqueues_in_LKM
해당 실습에서는 Waitqueue를 정적 사용, 동적으로 사용하여 실습을 진행했습니다.
## 관련 개념
#### 1. **대기 큐 (Wait Queue)**
- **정의**: 대기 큐는 커널에서 자원이 준비되지 않았을 때, 프로세스가 대기하는 동안 이를 관리하는 자료 구조입니다.
- **역할**:
  - 자원이 준비될 때까지 프로세스를 잠재워 두고, 자원이 준비되면 프로세스를 깨워서 다시 실행될 수 있도록 합니다.
  
#### 2. **블로킹 상황**
블로킹은 특정 작업이 완료될 수 없는 상태에서 프로세스가 대기하는 상황을 의미합니다. 대기하는 동안 프로세스는 대기 큐에 등록되며, 자원이 준비될 때까지 블로킹 상태가 유지됩니다.

#### 2-1. **쓰기 작업 불가능 (Buffer Full)**
- **상황**: 버퍼가 가득 차서 데이터를 더 이상 기록할 수 없는 상태입니다.
- **예시**: 버퍼가 가득 찼을 때, `write` 작업을 시도했지만 공간이 없어 데이터를 기록할 수 없는 경우.
- **결과**: 이 상황에서는 프로세스가 블로킹 상태로 전환되어 버퍼에 공간이 생길 때까지 대기 큐에서 잠들게 됩니다.

#### 2-2. **읽기 작업 불가능 (Buffer Empty)**
- **상황**: 버퍼가 비어 있어 읽을 데이터가 없는 상태입니다.
- **예시**: 버퍼에 데이터가 없는데 `read` 작업을 시도한 경우.
- **결과**: 프로세스는 데이터를 읽을 수 없으므로 블로킹 상태로 전환되어 데이터가 버퍼에 채워질 때까지 대기 큐에서 대기합니다.

#### 3. **블로킹 상황 해결 과정**
- **대기 큐**: 자원이 준비될 때까지 프로세스를 잠재우는 큐.
  - 자원이 준비되면 대기 큐에서 프로세스가 깨어나 작업을 다시 시도합니다.
  
#### 4. **요약**
- **대기 큐**: 자원이 준비될 때까지 프로세스를 대기시키는 커널 자료 구조.
- **블로킹 상태**: 자원이 준비되지 않아서 작업이 진행될 수 없을 때 발생하는 상태.
  - **쓰기 불가능**: 버퍼가 가득 찼을 때, 쓰기 작업은 블로킹됨.
  - **읽기 불가능**: 버퍼가 비어 있을 때, 읽기 작업은 블로킹됨.

## DEMO
 **대기 큐(wait queue)**를 사용하여 특정 조건이 만족될 때까지 스레드를 잠재우고, 조건이 충족되면 깨워서 작업을 처리하는 기법을 사용하고 있습니다.
 
### 1. **대기 큐 선언**
코드에서는 두 개의 대기 큐를 선언하고 있습니다. 하나는 정적으로 선언되고, 다른 하나는 동적으로 초기화됩니다.

- **정적 선언**:
  ```c
  DECLARE_WAIT_QUEUE_HEAD(wq1);
  ```
  `wq1`는 **정적으로 선언된 대기 큐**로, 바로 사용할 수 있습니다.

- **동적 선언 및 초기화**:
  ```c
  static wait_queue_head_t wq2;
  ```
  `wq2`는 동적으로 선언된 대기 큐입니다. 이후 `init_waitqueue_head()` 함수를 사용해 대기 큐를 초기화합니다:
  ```c
  init_waitqueue_head(&wq2);
  ```

### 2. **대기 큐에서 기다리기 (Blocking)**

스레드 함수인 `thread_function()`에서 대기 큐를 통해 스레드를 대기 상태로 두는 로직이 있습니다.

#### 첫 번째 대기 큐 (`wq1`) 사용:
```c
wait_event(wq1, watch_var == 11);
printk("waitqueue - watch_var is now 11!\n");
```
- **`wait_event()`**는 대기 큐 `wq1`에서 `watch_var == 11` 조건이 참이 될 때까지 스레드를 블로킹 상태로 만듭니다.
- 즉, `watch_var`가 11이 되기 전까지 해당 스레드는 대기 큐에서 잠들어 대기합니다.
- `watch_var`가 11이 되는 순간(다른 곳에서 변경 후 `wake_up(&wq1)`가 호출된 순간) 스레드는 깨어나서 실행을 재개하고 `"watchqueue - watch_var is now 11!"` 메시지를 출력합니다.

#### 두 번째 대기 큐 (`wq2`) 사용:
```c
while(wait_event_timeout(wq2, watch_var == 22, msecs_to_jiffies(5000)) == 0)
    printk("waitqueue - watch_var is still not 22, but timeout elapsed!\n");
printk("waitqueue - watch_var is now 22!\n");
```
- **`wait_event_timeout()`**은 대기 큐 `wq2`에서 `watch_var == 22` 조건이 참이 될 때까지 또는 **5초 동안** 대기합니다.
- 대기 중에 조건이 충족되지 않으면 **타임아웃**이 발생하고, 타임아웃이 발생할 때마다 `"waitqueue - watch_var is still not 22, but timeout elapsed!"` 메시지를 출력합니다.
- 조건이 충족되어 `watch_var`가 22가 되면, 대기에서 풀려 `"waitqueue - watch_var is now 22!"` 메시지가 출력됩니다.

### 3. **대기 큐 깨우기 (Waking up)**

대기 큐에서 스레드를 깨우는 부분은 `my_write()` 함수와 `my_module_exit()` 함수에서 이루어집니다.

#### `my_write()`에서 대기 큐 깨우기:
```c
wake_up(&wq1);
wake_up(&wq2);
```
- `my_write()` 함수는 사용자로부터 입력을 받아 `watch_var` 값을 변경하고, 그 후 `wake_up()`을 통해 대기 큐 `wq1`과 `wq2`에 있는 스레드를 깨웁니다.
- 이는 `watch_var`가 갱신되었으므로, 대기 상태에 있던 스레드들이 다시 실행을 재개하도록 신호를 보내는 역할을 합니다.

#### 모듈 종료 시 대기 큐 깨우기 (`my_module_exit()`):
```c
watch_var = 11;
wake_up(&wq1);
mdelay(10);
watch_var = 22;
wake_up(&wq2);
```
- 모듈이 언로드될 때, `watch_var`를 강제로 11과 22로 설정한 후 각각의 대기 큐를 깨웁니다.
- `wake_up(&wq1)`는 `wq1`에서 대기 중인 스레드를 깨우고, `wake_up(&wq2)`는 `wq2`에서 대기 중인 스레드를 깨웁니다.
- 이를 통해 모듈이 종료되기 전에 모든 대기 중인 스레드가 정상적으로 처리될 수 있도록 합니다.


![1](https://github.com/dlgus8648/Linux_device_driver/assets/139437162/c0245a5a-8df1-4390-8b06-36b359ede667)
![2](https://github.com/dlgus8648/Linux_device_driver/assets/139437162/958c41ae-e154-4e52-93c1-303a694295dd)
![3](https://github.com/dlgus8648/Linux_device_driver/assets/139437162/9ff59a7c-57ab-4b86-bde2-b128c0b9455b)
![4](https://github.com/dlgus8648/Linux_device_driver/assets/139437162/b73fa627-3f25-47f3-8cf3-7ebc40e6babd)
