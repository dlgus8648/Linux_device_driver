# 19_DMA

## 관련개념


### 1. **DMA (Direct Memory Access)**

#### **도입 배경**
전통적인 시스템에서는 **CPU**가 모든 **메모리 전송 작업**을 직접 처리합니다. 예를 들어, 데이터가 장치에서 메모리로 이동하거나 메모리에서 장치로 이동할 때, CPU는 해당 데이터를 직접 읽고 쓰는 작업을 해야 했습니다. 이 과정은 매우 **비효율적**이었고, 특히 대용량 데이터 전송이 필요한 경우 **CPU의 성능을 저하시킬 수 있는 병목**이 발생했습니다.

**DMA(Direct Memory Access)** 는 이러한 문제를 해결하기 위해 도입되었습니다. DMA는 **하드웨어 컨트롤러**로, CPU의 개입 없이 메모리에서 다른 장치로 데이터를 직접 전송하거나 그 반대의 작업을 수행합니다. 이를 통해 CPU는 데이터 전송 작업에서 벗어나 **다른 연산 작업**을 수행할 수 있어 **시스템 성능**을 크게 향상시킬 수 있습니다.

#### **DMA의 주요 기능**
- **직접 메모리 접근**: DMA 컨트롤러가 메모리의 한 위치에서 다른 위치로 데이터를 전송할 수 있습니다.
- **CPU 개입 없음**: DMA 작업 중에는 CPU가 관여하지 않으므로 CPU는 다른 작업을 수행할 수 있습니다.
- **인터럽트 기반 알림**: DMA 전송이 완료되면 **인터럽트**를 발생시켜 CPU에 알립니다.
  
#### **도입 효과**
- **성능 최적화**: CPU가 메모리 전송 작업을 직접 수행하지 않음으로써 CPU 리소스가 절약되고, **멀티태스킹** 성능이 향상됩니다.
- **대용량 데이터 전송**: 대량의 데이터를 빠르게 전송할 수 있어 **실시간 시스템**이나 **임베디드 시스템**에서 매우 유용합니다.

---

### 2. **스캐터-개더 (Scatter-Gather)**

#### **도입 배경**
대규모 데이터를 전송할 때, **연속적인 메모리 블록**을 할당하는 것이 어려운 경우가 많습니다. 기존의 DMA 방식은 **연속적인 메모리 블록**에서만 데이터를 전송할 수 있어, 메모리 단편화나 대규모 데이터를 처리할 때 **제한**이 있었습니다. 이를 해결하기 위해 **스캐터-개더** 기법이 도입되었습니다.

**스캐터-개더(Scatter-Gather)** 는 DMA 컨트롤러가 **비연속적인 메모리 블록**에 있는 데이터를 한 번에 모아서(Scatter) **연속적으로 전송**하거나, **연속적인 데이터를 여러 비연속적인 위치**로 분산(Gather)하여 전송할 수 있도록 하는 기법입니다. 이를 통해 **메모리 단편화 문제**를 해결하고, 대규모 데이터 전송을 더 효율적으로 수행할 수 있습니다.

#### **Scatter-Gather의 주요 기능**
- **비연속적 메모리 블록**: 여러 개의 **비연속적인 메모리 블록**을 하나의 DMA 전송으로 처리할 수 있습니다.
- **효율적인 대용량 데이터 전송**: 연속적인 메모리 블록 할당이 어려운 경우에도 대규모 데이터를 효율적으로 처리할 수 있습니다.
- **전송 리스트 사용**: 전송할 데이터의 **주소와 크기**가 포함된 리스트를 사용하여 비연속적인 메모리 블록을 하나의 전송으로 처리합니다.

#### **도입 효과**
- **메모리 단편화 문제 해결**: 시스템 메모리가 조각난 상황에서도 대규모 데이터 전송이 가능합니다.
- **CPU 부담 감소**: 비연속적인 메모리 블록을 처리할 때 CPU의 개입이 최소화되므로, 성능 저하를 방지할 수 있습니다.
- **효율적인 I/O 처리**: 다양한 하드웨어 장치와의 입출력(I/O) 작업을 효율적으로 처리할 수 있어 **스토리지 시스템**이나 **네트워크 인터페이스** 등에서 자주 사용됩니다.

---

### 3. **Completion**

#### **도입 배경**
DMA와 같은 비동기 작업에서는 CPU가 직접 데이터 전송을 처리하지 않기 때문에, **작업이 완료되었는지 확인할 방법**이 필요합니다. DMA 전송이 완료되면 CPU가 이를 인식해야 후속 작업을 진행할 수 있지만, DMA가 완료되기 전까지는 CPU가 대기해야 하는 상황이 발생할 수 있습니다. 이 경우 **동기화 문제**가 발생하게 됩니다.

**Completion**은 이러한 비동기 작업의 **동기화 문제**를 해결하기 위해 도입된 커널의 동기화 메커니즘입니다. Completion은 **비동기 작업이 완료될 때까지 대기**하고, 작업이 완료되면 이를 알려주는 방식으로 동작합니다. 이를 통해 CPU는 비동기 작업의 완료 여부를 효율적으로 기다릴 수 있습니다.

#### **Completion의 주요 기능**
- **비동기 작업 완료 대기**: `wait_for_completion()`을 통해 CPU는 비동기 작업이 완료될 때까지 대기할 수 있습니다.
- **작업 완료 신호 전달**: DMA나 다른 비동기 작업이 완료되면 `complete()`를 호출하여 작업이 완료되었음을 알립니다.
- **타임아웃 설정**: `wait_for_completion_timeout()`을 사용하여 일정 시간 동안만 대기할 수 있으며, 시간 초과 시 오류로 처리할 수 있습니다.

#### **도입 효과**
- **비동기 작업의 동기화**: CPU가 직접 작업을 처리하지 않고도, **DMA 전송**과 같은 비동기 작업의 완료 여부를 동기화할 수 있습니다.
- **타임아웃 처리**: 작업이 예상보다 오래 걸릴 경우, CPU는 일정 시간 대기 후 타임아웃 처리할 수 있어 **효율적인 자원 관리**가 가능합니다.
- **복잡한 동기화 문제 해결**: 여러 개의 비동기 작업이 동시에 진행될 때, 각 작업의 완료 시점을 관리하는데 유용합니다.

---

### 4. **DMA와 Scatter-Gather, Completion의 통합 동작**

이 세 가지 개념은 주로 **대규모 데이터 전송**과 **실시간 처리 시스템**에서 통합적으로 사용됩니다. 예를 들어, **비연속적인 메모리 블록**에서 데이터를 **DMA**를 통해 빠르게 전송하면서, **Completion**을 통해 작업 완료 여부를 CPU에 알려주는 방식입니다. 이를 통해 시스템은 **비동기 데이터 전송** 중에도 CPU 리소스를 최소한으로 사용하며, 효율적인 메모리 전송을 보장할 수 있습니다.

#### 예시: 네트워크 패킷 전송
- **DMA**는 네트워크 카드에서 메모리로 대량의 패킷 데이터를 전송합니다.
- **Scatter-Gather**는 패킷 데이터가 여러 비연속적인 메모리 블록에 분산되어 있을 때, 이를 효율적으로 모아 전송하는 데 사용됩니다.
- **Completion**은 패킷 전송이 완료되면 CPU에 이를 알려줘, CPU가 패킷을 처리할 수 있도록 합니다.

---


## **19_DMA 실습 목표**

이번 실습의 목표는 **DMA(Direct Memory Access)** 를 사용하여 리눅스 커널에서 **메모리 복사** 작업을 수행하는 방법을 배우는 것입니다. CPU를 사용하지 않고, 하드웨어인 DMA 컨트롤러를 통해 RAM의 한 영역에서 다른 영역으로 데이터를 효율적으로 복사하는 방법을 이해하고 구현합니다. 이를 통해 CPU 리소스를 절약하고 성능을 향상시키는 방법을 학습합니다.

## 1. **코드 설명**

### 1.1. **기본 구조**

DMA를 사용하는 리눅스 커널 모듈을 구현하기 위해, 다음과 같은 단계를 따릅니다:

1. **DMA 엔진과 관련된 헤더 파일 포함**: `dmaengine.h`, `completion.h` 등 DMA 및 커널 모듈 개발에 필요한 헤더 파일을 포함합니다.
   
2. **DMA 관련 구조체 및 변수 선언**: DMA 작업을 처리하기 위해 필요한 변수를 선언합니다.
   - **dma_cap_mask_t mask**: DMA 채널의 특성을 설정하기 위한 마스크 변수.
   - **struct dma_chan chan**: DMA 채널을 위한 변수.
   - **dma_async_tx_descriptor chan_desc**: DMA 전송 요청을 담는 디스크립터.
   - **dma_cookie_t cookie**: DMA 전송 상태를 추적하기 위한 쿠키.
   - **dma_addr_t source_addr, dest_addr**: 소스 및 목적지 메모리의 물리적 주소를 저장.
   - **completion 변수**: DMA 전송 완료를 대기하는데 사용되는 구조체.
   
3. **DMA 채널 요청**: DMA 채널을 요청하는 `dma_request_channel()` 함수를 사용하여 DMA 채널을 확보합니다. 이때, `dma_cap_set()`을 이용하여 사용할 기능을 설정합니다.
   
4. **메모리 할당**: DMA에서 사용할 **소스와 목적지 버퍼**를 위해 메모리를 할당합니다. 이때 **dma_alloc_coherent()** 함수를 사용하여 **캐시되지 않은(non-cacheable)** 메모리를 할당하며, 해당 메모리의 물리적 주소를 반환합니다.

5. **DMA 디스크립터 설정**: `dmaengine_prep_dma_memcpy()` 함수를 이용하여 DMA 전송 작업을 설정합니다. 이 함수는 소스와 목적지 주소, 전송할 데이터 크기, 전송 방향 등을 설정합니다.

6. **DMA 전송 시작**: `dmaengine_submit()` 함수를 통해 전송 요청을 제출하고, `dma_async_issue_pending()`으로 전송을 시작합니다.

7. **DMA 전송 완료 대기**: `completion`을 사용하여 DMA 전송이 완료될 때까지 대기하며, 3초의 타임아웃을 설정합니다.

8. **전송 상태 확인**: DMA 전송 완료 후 `dma_async_is_tx_complete()` 함수를 사용하여 전송이 성공적으로 완료되었는지 확인합니다.

### 2.2. **DMA 전송 완료 콜백 함수**
```c
static void my_dma_transfer_completed(void *completion)
{
    struct completion *cmp = completion;
    complete(cmp);  // DMA 전송이 완료되었음을 알림
}
```
- DMA 전송이 완료되면 커널은 **콜백 함수**를 호출합니다. 이 함수는 **completion 구조체**를 받아, DMA 작업이 완료되었음을 알리는 `complete()` 함수를 호출합니다.


## B. Demo
![dma](https://github.com/user-attachments/assets/f6a8b632-f317-4d89-920a-d138a3ac533d)

## C. 함수 호출 순서
이 코드는 RAM에서 RAM으로 데이터를 복사하는 DMA(Direct Memory Access)를 사용하는 간단한 예제입니다. DMA 채널을 요청하고 데이터를 전송하며, DMA 전송이 완료되면 콜백 함수를 호출하여 작업이 완료되었음을 알립니다. 함수 호출 순서는 다음과 같습니다.

### 1. 모듈 로드 시 (`my_init` 호출)
   - `module_init()` 매크로에 의해 **my_init** 함수가 커널 모듈이 로드될 때 호출됩니다.

#### 1-1. **dma_cap_zero()** 및 **dma_cap_set()** 호출
   - **DMA 기능 설정**: `dma_cap_zero()`로 DMA 기능 마스크를 초기화하고, `dma_cap_set()`으로 `DMA_SLAVE`와 `DMA_PRIVATE` 기능을 설정합니다.

#### 1-2. **dma_request_channel()** 호출
   - **DMA 채널 요청**: `dma_request_channel()` 함수로 DMA 채널을 요청합니다. DMA 마스크와 일치하는 채널이 있으면 `chan`에 할당됩니다.
   - 채널을 요청하지 못하면 에러 메시지를 출력하고 함수가 종료됩니다.

#### 1-3. **dma_alloc_coherent()** 호출
   - **DMA 메모리 할당**: `dma_alloc_coherent()` 함수로 소스(`src_buf`)와 목적지(`dst_buf`) 버퍼에 DMA 전송에 사용할 메모리를 할당합니다. `src_addr`와 `dst_addr`에는 이 메모리의 DMA 주소가 저장됩니다.

#### 1-4. **메모리 초기화 (`memset()`)**
   - 할당된 소스 버퍼는 0x12로, 목적지 버퍼는 0x00으로 각각 초기화합니다.

#### 1-5. **dmaengine_prep_dma_memcpy()** 호출
   - **DMA 전송 준비**: `dmaengine_prep_dma_memcpy()` 함수로 소스 주소에서 목적지 주소로 데이터를 전송할 DMA 전송 작업을 준비합니다. 1024 바이트의 데이터를 전송할 준비를 하고, 이 작업을 설명하는 `chan_desc` 구조체가 반환됩니다.
   - 전송 준비가 실패하면 에러 메시지를 출력하고 리소스를 해제한 후 함수가 종료됩니다.

#### 1-6. **init_completion()** 호출
   - **완료 구조체 초기화**: DMA 전송 완료 여부를 확인하기 위한 `completion` 구조체를 초기화합니다. 이 구조체는 전송이 완료되면 콜백에서 신호를 보내 대기 상태를 해제하는 데 사용됩니다.

#### 1-7. **DMA 콜백 설정**
   - DMA 전송이 완료되면 호출될 콜백 함수 `my_dma_transfer_completed()`를 설정합니다. 이 함수는 DMA가 완료되면 `complete()`를 호출하여 작업 완료를 신호합니다.

#### 1-8. **dmaengine_submit()** 호출
   - **DMA 전송 제출**: `dmaengine_submit()` 함수로 DMA 작업을 제출합니다. `cookie` 값은 이 전송 작업의 ID로, 나중에 전송이 완료되었는지 확인하는 데 사용됩니다.

#### 1-9. **dma_async_issue_pending()** 호출
   - **DMA 전송 시작**: `dma_async_issue_pending()` 함수로 DMA 전송을 시작합니다.

#### 1-10. **wait_for_completion_timeout()** 호출
   - **전송 완료 대기**: `wait_for_completion_timeout()` 함수로 DMA 전송이 완료될 때까지 3초 동안 대기합니다. 대기 시간이 초과되면 "Timeout!" 메시지를 출력하고, 그렇지 않으면 다음 단계로 진행합니다.

#### 1-11. **dma_async_is_tx_complete()** 호출
   - **DMA 전송 완료 여부 확인**: `dma_async_is_tx_complete()` 함수로 DMA 전송이 완료되었는지 확인합니다.
   - 전송이 성공적으로 완료되면 성공 메시지와 함께 소스 및 목적지 버퍼 값을 출력합니다. 실패하면 에러 메시지를 출력합니다.

#### 1-12. **dmaengine_terminate_all()** 호출
   - **DMA 작업 종료**: `dmaengine_terminate_all()` 함수로 현재 DMA 채널에서 모든 전송 작업을 종료합니다.

#### 1-13. **dma_free_coherent()** 호출
   - **메모리 해제**: `dma_free_coherent()` 함수로 소스 및 목적지 버퍼에 할당된 DMA 메모리를 해제합니다.

#### 1-14. **dma_release_channel()** 호출
   - **DMA 채널 해제**: `dma_release_channel()` 함수로 요청된 DMA 채널을 해제합니다.

### 2. 모듈 언로드 시 (`my_exit` 호출)
   - `module_exit()` 매크로에 의해 **my_exit** 함수가 모듈이 언로드될 때 호출됩니다.

#### 2-1. **모듈 언로드**
   - "Goodbye, Kernel" 메시지를 출력하고 모듈이 종료됩니다.

### 함수 호출 순서 요약

1. **my_init()** → 모듈 로드, DMA 채널 요청 및 전송 준비
   - `dma_cap_zero()` → `dma_cap_set()` → `dma_request_channel()` → `dma_alloc_coherent()` → `memset()` → `dmaengine_prep_dma_memcpy()` → `init_completion()` → `dmaengine_submit()` → `dma_async_issue_pending()` → `wait_for_completion_timeout()` → `dma_async_is_tx_complete()` → `dmaengine_terminate_all()` → `dma_free_coherent()` → `dma_release_channel()`

2. **my_dma_transfer_completed()** → DMA 전송 완료 시 콜백 호출
   - `complete()`로 전송 완료를 신호

3. **my_exit()** → 모듈 언로드

이 순서는 DMA를 사용하여 RAM에서 RAM으로 데이터를 복사하는 과정에서 발생하는 주요 함수 호출 흐름을 보여줍니다.
