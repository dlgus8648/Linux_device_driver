# 09_High_Resolution_Timer
## 관련개념

리눅스 커널에서 시간과 타이머는 중요한 역할을 하며, 시스템 성능과 동작을 제어하는 데 사용됩니다.
이와 관련된 몇 가지 주요 개념인 **jiffies**, **hrtimer**(고해상도 타이머), **기본 타이머**(보통 "커널 타이머"라고도 함) 및 **고해상도 타이머**에 대해 각각 자세히 설명하겠습니다.

### 1. **Jiffies**
- `jiffies`는 리눅스 커널에서 시스템 시간을 추적하는 기본 단위입니다. 이는 커널이 일정 주기마다 증가시키는 카운터로, 하드웨어 타이머가 생성하는 **타이머 틱**(timer tick)을 기반으로 동작합니다.
- 스케줄러용 타이머가 발생시키는 인터럽트를 Tick이라고 합니다.
- 1 Tick 당 소요되는 시간을 Jiffies라고 합니다.
- 즉, 1초당 발생하는 Jiffies를 Hz라고 합니다.(= 1초당 발생되는 타이머 인터럽트 횟수)
- 
#### 주요 특징:
- `jiffies`는 커널이 부팅된 이후부터 지금까지 발생한 타이머 틱의 개수를 저장하는 전역 변수입니다.
- 타이머 틱의 주기는 시스템마다 다를 수 있지만, 일반적으로 100Hz에서 1000Hz 사이로 설정됩니다. 예를 들어, 1000Hz라면 1초에 1000번 `jiffies`가 증가합니다.
- `HZ`라는 상수는 1초에 발생하는 타이머 틱의 수를 나타내며, `HZ`에 따라 `jiffies`의 증가 속도가 결정됩니다.



### 2. **기본 타이머 (Kernel Timer)**
리눅스 커널은 **기본 타이머**(또는 "커널 타이머") 메커니즘을 통해 지연 작업이나 주기적인 작업을 처리합니다. 기본 타이머는 `jiffies`를 기반으로 일정한 시간이 지난 후 특정 함수가 실행되도록 예약할 수 있습니다.

#### 주요 특징:
- 기본 타이머는 정밀도가 낮습니다. 이는 타이머 틱 주기(HZ)에 의존하므로, 1ms 단위 이하의 정확한 시간을 요구하는 경우에는 적합하지 않습니다.
- 타이머는 `jiffies`에 기반하여 동작하기 때문에 시스템의 전반적인 응답 시간에 비례한 일정 수준의 지연이 발생할 수 있습니다.

### 3. **고해상도 타이머 (High Resolution Timer, hrtimer)**
`hrtimer`는 리눅스 커널에서 **고정밀 시간 작업**을 처리하기 위한 타이머 메커니즘입니다. 기본 타이머가 낮은 정밀도(타이머 틱 간격에 의존)인 반면, `hrtimer`는 **마이크로초** 또는 **나노초** 수준의 정확한 타이밍을 제공합니다.

#### 주요 특징:
- **정밀도가 매우 높음**: 마이크로초 및 나노초 단위의 정확한 시간 측정과 지연을 제공합니다.
- **커널 틱(tick)과 무관하게 동작**: 타이머 틱에 의존하지 않고, 고정밀 하드웨어 타이머를 사용해 일정한 시간이 정확히 지났을 때 호출됩니다.
- RTOS이나 정밀 타이밍을 요구하는 작업에서 주로 사용됩니다.

#### 주요 함수:
해당 실습은 고해상도 타이머를 설정하고 이를 활용하여 100ms이 지나면 지정된 콜백 함수(test_hrtimer_handler)가 호출되도록 사용되었습니다. 
이 코드에서 `hrtimer`는 고해상도 타이머를 설정하고 이를 활용하여 일정 시간(여기서는 100ms)이 지나면 지정된 콜백 함수(`test_hrtimer_handler`)가 호출되도록 사용되었습니다. 각 단계별로 타이머가 어떻게 사용되었는지 설명드리겠습니다.

### 주요 흐름:

1. **hrtimer 초기화 (`hrtimer_init`)**:
   ```c
   hrtimer_init(&my_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
   ```
   여기서 `hrtimer_init()` 함수는 타이머 객체(`my_hrtimer`)를 초기화합니다. 
   - `CLOCK_MONOTONIC`: 이 타이머는 시스템이 부팅된 이후의 시간을 측정합니다(즉, 시스템 시간을 기준으로 동작하지 않으며, 절대 시간이 아니라 경과 시간에 의존).
   - `HRTIMER_MODE_REL`: 상대적인 시간을 기준으로 타이머가 작동합니다. 즉, 타이머를 시작한 시점으로부터 100ms 후에 호출됩니다.

2. **타이머 콜백 함수 설정**:
   ```c
   my_hrtimer.function = &test_hrtimer_handler;
   ```
   타이머가 만료되었을 때 호출될 콜백 함수로 `test_hrtimer_handler()`를 지정합니다. 이 함수는 타이머가 만료된 후 호출됩니다.

3. **타이머 시작 (`hrtimer_start`)**:
   ```c
   start_t = jiffies;
   hrtimer_start(&my_hrtimer, ms_to_ktime(100), HRTIMER_MODE_REL);
   ```
   `hrtimer_start()` 함수는 타이머를 시작합니다. 
   - `ms_to_ktime(100)`: 100ms 후에 타이머가 만료되도록 설정되었습니다.
   - `HRTIMER_MODE_REL`: 현재 시점으로부터 100ms 뒤에 타이머가 만료됨을 의미합니다.

4. **타이머가 만료되면 콜백 함수 실행 (`test_hrtimer_handler`)**:
   ```c
   static enum hrtimer_restart test_hrtimer_handler(struct hrtimer *timer) {
       /* Get current time */
       u64 now_t = jiffies;
       printk("start_t - now_t = %u\n", jiffies_to_msecs(now_t - start_t));
       return HRTIMER_NORESTART;
   }
   ```
   타이머가 만료되면 `test_hrtimer_handler()` 함수가 호출됩니다. 이 함수에서는 현재 시점의 `jiffies` 값을 가져와, 타이머가 시작된 시점(`start_t`)과 현재 시점의 차이를 계산해 그 시간을 밀리초로 출력합니다. 

   - `jiffies_to_msecs(now_t - start_t)`: 두 시점의 `jiffies` 차이를 밀리초 단위로 변환하여 경과된 시간을 출력합니다.
   - `HRTIMER_NORESTART`: 타이머가 한 번 실행된 후 재시작되지 않도록 설정합니다.

### 요약:
- `hrtimer_init()`을 통해 고해상도 타이머를 초기화하고, 100ms 후에 타이머가 만료되면 `test_hrtimer_handler()`가 호출되도록 설정했습니다.
- `hrtimer_start()`는 상대적인 100ms의 지연을 기준으로 타이머를 시작하며, 타이머가 만료되면 등록된 콜백 함수가 실행됩니다.
- 콜백 함수에서는 `jiffies`를 이용해 타이머 시작 시점과 현재 시점 간의 경과 시간을 출력합니다.
- 이 과정에서 타이머는 고정밀한 시간 제어를 위해 사용됩니다.
### 4. **기본 타이머와 고해상도 타이머의 비교**

| **특성**                   | **기본 타이머**                                   | **고해상도 타이머 (hrtimer)**                  |
|----------------------------|-------------------------------------------------|------------------------------------------------|
| **정밀도**                  | 낮음 (타이머 틱에 의존)                          | 매우 높음 (마이크로초 또는 나노초 단위)          |
| **타이머 틱에 의존 여부**   | 의존함                                          | 의존하지 않음                                   |
| **사용 용도**               | 일반적인 지연 및 간단한 시간 제어 작업           | 실시간 애플리케이션 및 정밀 타이밍을 요구하는 작업 |
| **구현 복잡도**             | 상대적으로 간단함                               | 상대적으로 복잡함                               |




![1](https://github.com/dlgus8648/Linux_device_driver/assets/139437162/ac3e40f3-c113-40a6-b3d6-4c68233eda78)

### 설명

1. **`[   73.506131] Hello, Kernel!`**
   - **타임스탬프**: 커널 부팅 후 `73.506131초` 지남.
   - **메시지**: "Hello, Kernel!" - 커널로부터의 정보성 메시지.

2. **`[   73.606154] start_t - now_t = 100`**
   - **타임스탬프**: 커널 부팅 후 `73.606154초` 지남.
   - **메시지**: 두 타임스탬프 `start_t`와 `now_t`의 차이가 `100`이라는 의미.
   - **설명**: 
     - 차이 `start_t - now_t`가 `100밀리초`라는 뜻.
     - 계산: `73.606154 - 73.506131 = 0.100023초 = 100밀리초`.

### 요약

이 커널 메시지는 커널이 부팅된 지 약 `73.506131초` 후에 "Hello, Kernel!"이라는 메시지를 출력했고, 이후 `73.606154초`가 지난 시점에 두 타임스탬프(`start_t`와 `now_t`) 사이의 차이가 `100밀리초`임을 계산하고 출력한 것을 나타냅니다.

