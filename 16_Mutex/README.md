# 16_Mutex

## 관련 개념
![상호배제도구설명](https://github.com/user-attachments/assets/6ece2323-f681-4348-87be-bd7684997e77)

### 1. 임계구역 (Critical Section)
임계구역은 멀티스레드 환경에서 여러 스레드가 동시에 접근하면 문제가 발생할 수 있는 **공유 자원의 코드 영역**입니다. 
이 코드 영역은 동시에 하나의 스레드만 접근해야 하며, 다른 스레드는 접근을 대기해야 합니다.

### 2. 뮤텍스 (Mutex, Mutual Exclusion)
뮤텍스는 임계구역에 **한 번에 하나의 스레드만 진입**할 수 있도록 하는 동기화 메커니즘입니다. 
  - 뮤텍스는 **잠금(lock)** 과 **해제(unlock)** 로 관리됩니다.
  - 한 스레드가 자원을 사용할 때, 다른 스레드는 자원이 해제될 때까지 **대기**해야 합니다.
  - 뮤텍스는 상태가 변할 때까지 스레드가 **블록(block)** 되어 대기하게 됩니다.

### 3. 세마포어 (Semaphore)
세마포어는 여러 스레드가 자원에 접근할 때, **동시 허용 가능한 스레드 수**를 제어하는 동기화 메커니즘입니다. 
일반적인 세마포어는 정해진 개수의 스레드가 동시에 자원에 접근할 수 있습니다.



### 4. Completion
Completion은 **커널에서 사용되는 동기화 메커니즘**으로, 한 스레드가 특정 작업을 완료할 때까지 다른 스레드가 **대기**하도록 하는 구조입니다. 
뮤텍스나 세마포어와 달리 주로 **작업의 완료 여부를 기다리는 상황**에서 사용됩니다.

### 5. 스핀락 (Spinlock)
스핀락은 자원에 대한 잠금을 요청한 스레드가 **대기하는 동안 계속해서 잠금의 해제를 확인**하며 "스핀"하는 방식의 락입니다.
대기하는 동안 **CPU를 계속 사용**하기 때문에, 짧은 시간 내에 잠금이 해제될 것으로 예상될 때 효과적입니다.

### 6. 시퀀스락 (Seqlock)
시퀀스락은 **읽기 성능을 최적화**하기 위한 동기화 메커니즘으로, **다중 읽기**와 **단일 쓰기** 상황에서 자주 사용됩니다. 쓰기가 없을 때는 락을 획득하지 않고도 데이터를 읽을 수 있으며, 쓰기 작업이 일어날 때만 잠금이 필요합니다.

---

## Demo
![my_mutex](https://github.com/user-attachments/assets/4480e0fe-1e2f-4c93-90d9-05d0d4d2c202)
## 설명
이미지에 표시된 **뮤텍스 동작**의 결과는 두 개의 스레드가 **뮤텍스 잠금(mutex_lock)** 을 통해 공유 자원(임계구역)에 접근하는 순서를 보여줍니다. 각 단계에서 중요한 포인트와 뮤텍스가 어떻게 작동하는지 자세히 설명하겠습니다.

### 1. **Init Threads**
- 처음에 스레드들이 생성되는 로그를 볼 수 있습니다. 
- `Init threads`라는 메시지가 출력되면서 **스레드 1**과 **스레드 2**가 생성됩니다. 

### 2. **Thread 1 실행 및 임계구역 진입**
- `Thread 1 was created and is running now!`라는 메시지에서 스레드 1이 시작된 것을 알 수 있습니다.
- 이어서 `Thread 1 is in critical section!`이라는 메시지가 출력됩니다. 이 메시지는 **뮤텍스 잠금(mutex_lock)** 이 성공적으로 수행되어 스레드 1이 공유 자원(임계구역)에 진입했음을 나타냅니다.
- 이 때 로그 타임스탬프를 보면 133.850634초에 진입했다는 것을 확인할 수 있습니다.

### 3. **Thread 2 실행 및 대기 상태**
- `Thread 2 was created and is running now!`에서 스레드 2가 생성되어 실행 중임을 확인할 수 있습니다.
- `Thread 2 is executed!`라는 메시지를 통해 스레드 2가 실행되고 있지만, **임계구역에 들어가지 못하고 기다리고 있음**을 나타냅니다. 이는 **뮤텍스가 잠긴 상태**이기 때문에 스레드 2가 진입할 수 없기 때문입니다.
- 스레드 1이 아직 **임계구역에서 작업을 수행 중**이므로, 스레드 2는 뮤텍스 잠금 해제를 기다려야 합니다.

### 4. **Thread 1의 임계구역 작업 완료**
- `Thread 1 is leaving the critical section!` 메시지가 133.867038초에 출력되며 스레드 1이 임계구역에서 빠져나온 것을 확인할 수 있습니다. 스레드 1의 임계구역 진입에서 빠져나오기까지 약 1초 정도 걸렸습니다.
- `Thread 1 finished execution!`에서 스레드 1의 실행이 완료되었음을 알 수 있습니다.

### 5. **Thread 2의 임계구역 진입**
- 이제 `Thread 2 is in critical section!`에서 스레드 2가 뮤텍스를 획득하고 **임계구역에 진입**했음을 알 수 있습니다. 타임스탬프는 133.867809초로 스레드 1이 떠난 직후입니다.
- 스레드 2도 임계구역에서 작업을 수행한 후, `Thread 2 is leaving the critical section!` 메시지가 135.378996초에 출력됩니다.
- `Thread 2 finished execution!`에서 스레드 2의 작업이 완료되었습니다.


두 개의 커널 스레드를 생성하고, 스레드 간에 공유 자원에 접근할 때 상호 배제를 위해 뮤텍스(mutex)를 사용하는 Linux 커널 모듈입니다.
각 스레드는 지정된 지연 시간 후에 임계 구역(critical section)에 접근하여 자원을 안전하게 처리합니다.

## C. 코드 설명

### 1. 모듈 로드 시 (`ModuleInit` 호출)
   - `module_init()` 매크로에 의해 **ModuleInit** 함수가 커널 모듈이 로드될 때 호출됩니다.

#### 1-1. **mutex_init()** 호출
   - **뮤텍스 초기화**: `mutex_init()` 함수는 글로벌 변수 `lock`에 뮤텍스를 초기화합니다. 이후 이 뮤텍스는 스레드 간의 자원 접근을 동기화하는 데 사용됩니다.

#### 1-2. **kthread_create()** 호출 (첫 번째 스레드 생성)
   - **첫 번째 커널 스레드 생성**: `kthread_create()` 함수로 `thread_function`을 실행하는 첫 번째 스레드(`kthread_1`)를 생성합니다.
   - 성공적으로 스레드가 생성되면 `wake_up_process()` 함수로 스레드를 시작합니다.
   - 실패 시 "Thread 1 could not be created!" 메시지를 출력하고 함수가 종료됩니다.

#### 1-3. **kthread_run()** 호출 (두 번째 스레드 생성 및 실행)
   - **두 번째 커널 스레드 생성 및 실행**: `kthread_run()` 함수는 `thread_function`을 실행하는 두 번째 스레드(`kthread_2`)를 생성하고 바로 실행합니다.
   - 성공 시 "Thread 2 was created and is running now!" 메시지를 출력합니다.
   - 실패 시 "Thread 2 could not be created!" 메시지를 출력하고, 첫 번째 스레드(`kthread_1`)를 중지한 후 함수가 종료됩니다.

#### 1-4. **모든 스레드가 정상적으로 실행 중** 
   - 두 스레드가 성공적으로 생성되면 "Both threads are running now!" 메시지를 출력합니다.

### 2. 스레드 실행 중 (`thread_function` 호출)
   - 각 스레드는 **thread_function** 함수에 의해 실행됩니다.

#### 2-1. **뮤텍스 잠금** (`mutex_lock()`)
   - 각 스레드는 "Thread X is executed!" 메시지를 출력한 후 **mutex_lock()**을 호출하여 뮤텍스를 잠급니다. 
   - 다른 스레드가 이미 임계 구역에 있다면, 해당 스레드는 뮤텍스가 해제될 때까지 대기합니다.

#### 2-2. **임계 구역 접근**
   - 스레드가 뮤텍스 잠금에 성공하면 "Thread X is in critical section!" 메시지를 출력하고 임계 구역에 들어갑니다.
   - 각 스레드는 `msleep()`으로 지정된 시간만큼 대기합니다. 스레드 1은 1초, 스레드 2는 500ms 동안 대기합니다.

#### 2-3. **뮤텍스 해제** (`mutex_unlock()`)
   - 대기 시간이 끝나면 "Thread X is leaving the critical section!" 메시지를 출력하고 **mutex_unlock()**을 호출하여 뮤텍스를 해제합니다.
   - 다른 스레드가 임계 구역에 접근할 수 있도록 뮤텍스가 해제됩니다.

#### 2-4. **스레드 종료**
   - 임계 구역을 떠난 후 "Thread X finished execution!" 메시지를 출력하고 스레드가 종료됩니다.

### 3. 모듈 언로드 시 (`ModuleExit` 호출)
   - `module_exit()` 매크로에 의해 **ModuleExit** 함수가 모듈이 언로드될 때 호출됩니다.
   - 현재 코드에서는 스레드 종료나 리소스 해제와 관련된 작업을 수행하지 않지만, 스레드가 중지되었다는 메시지를 출력합니다.

### 함수 호출 순서 요약

1. **ModuleInit()** → 모듈 로드, 뮤텍스 및 스레드 생성
   - `mutex_init()`으로 뮤텍스 초기화
   - `kthread_create()`로 첫 번째 스레드 생성 및 시작
   - `kthread_run()`으로 두 번째 스레드 생성 및 시작

2. **thread_function()** → 스레드 실행 중
   - `mutex_lock()`으로 뮤텍스 잠금
   - 임계 구역에 접근, `msleep()`으로 대기
   - `mutex_unlock()`으로 뮤텍스 해제
   - 스레드 종료

3. **ModuleExit()** → 모듈 언로드
   - 스레드 중지 메시지 출력 (현재는 스레드를 중지하는 코드는 포함되어 있지 않음)

이 순서는 커널 모듈에서 두 개의 커널 스레드를 생성하고, 뮤텍스를 사용하여 스레드 간의 임계 구역 접근을 제어하는 방법을 설명합니다.

